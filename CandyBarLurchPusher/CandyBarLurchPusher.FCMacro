#*****************************************************************************
#
#  System        : 
#  Module        : 
#  Object Name   : $RCSfile$
#  Revision      : $Revision$
#  Date          : $Date$
#  Author        : $Author$
#  Created By    : Robert Heller
#  Created       : Sun Jul 6 15:01:26 2025
#  Last Modified : <250708.1556>
#
#  Description	
#
#  Notes
#
#  History
#	
#*****************************************************************************
#
#    Copyright (C) 2025  Robert Heller D/B/A Deepwoods Software
#			51 Locke Hill Road
#			Wendell, MA 01379-9728
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# 
#
#*****************************************************************************


import FreeCAD as App
import Part, TechDraw, Mesh, MeshPart, TechDrawGui
from FreeCAD import Base

import math

import os
import sys
sys.path.append(os.path.dirname(__file__))

import DFRobotGearMotor

import time
from PySide.QtCore import QCoreApplication, QEventLoop, QTimer
def execute(loop, ms):
    timer = QTimer()
    timer.setSingleShot(True)
    
    timer.timeout.connect(loop.quit)
    timer.start(ms)
    loop.exec_()

def sleep(ms):
    if not QCoreApplication.instance():
        app = QCoreApplication([])
        execute(app, ms)
    else:
        loop = QEventLoop()
        execute(loop, ms)

from abc import ABCMeta, abstractmethod, abstractproperty

class BirchPanel(metaclass=ABCMeta):
    @staticmethod
    def FitPanel(page,lastX,lastY,lengthX,lengthY,deltaY,minX,minY,maxX,maxY):
        views = page.getAllViews()
        currentX = lastX
        currentY = lastY
        rotation = 0
        if (lengthY > 2*deltaY and lengthX < deltaY) or \
            lengthY > lengthX*2:
            temp = lengthX
            lengthX = lengthY
            lengthY = temp
            rotation = 90
        if currentX+lengthX < maxX and \
           currentY+lengthY < maxY:
            deltaY = max(deltaY,lengthY+10)
            return (True, currentX, currentY, lengthX, lengthY, deltaY, rotation)
        elif currentX+lengthX > maxX and \
           currentY+lengthY+deltaY < maxY and \
           minX+lengthX < maxX:
            currentX = minX
            currentY += deltaY
            return (True, currentX, currentY, lengthX, lengthY+10, currentY+10, rotation)
        elif currentY+lengthY > maxY and \
             currentY+lengthX < maxY and \
             currentX+lengthY < maxX:
            temp = lengthX
            lengthX = lengthY
            lengthY = temp
            if rotation == 0:
                rotation = 90
            else:
                rotation = 0
            deltaY = max(deltaY,lengthY+10)
            return (True, currentX, currentY, lengthX, lengthY, deltaY, rotation)
        elif currentY+deltaY+lengthX < maxY and \
             minX+lengthY < maxX:
            temp = lengthX
            lengthX = lengthY
            lengthY = temp
            if rotation == 0:
                rotation = 90
            else:
                rotation = 0
            currentX = minX
            currentY += deltaY
            return (True, currentX, currentY, lengthX, lengthY+10, currentY+10, rotation)
        else:
            return (False, lastX, lastY, lengthX, lengthY, deltaY, rotation)
    @staticmethod
    def Thickness():
        return .125 * 25.4
    @property
    def FingerWidth(self):
        return .5 * 25.4
    @property
    def Color(self):
        return (.8,.8,.8)
    @abstractmethod
    def PanelPage(self,techDoc,page,lastX,lastY,deltaY,*,minX=50,minY=50,
                                             maxX=(24*25.4)-50,
                                             maxY=(16*25.4)-50):
        pass

class InstanceIter(metaclass=ABCMeta):
    @classmethod
    def SetIter(cls):
        #print('*** InstanceIter.__iter__(',cls,')')
        try:
            panels = cls.__Panels
        except AttributeError:
            cls.__Panels = set()
        return cls.__Panels.__iter__()
    def __del__(self):
        #print('*** InstanceIter.__del__(',self,')')
        #print('*** InstanceIter.__del__(): self.__class__ is ',self.__class__)
        try:
            panels = self.__class__.__Panels
        except AttributeError:
            self.__class__.__Panels = set()
        self.__class__.__Panels.remove(self)
    def __init__(self):
        #print('*** InstanceIter.__init__(',self,')')
        #print('*** InstanceIter.__init__(): self.__class__ is ',self.__class__)
        try:
            panels = self.__class__.__Panels
        except AttributeError:
            self.__class__.__Panels = set()
        self.__class__.__Panels.add(self)
        #print('*** InstanceIter.__init__(): self.__class__.__Panels is',self.__class__.__Panels)
    @classmethod
    def SortedList(cls):
        return cls.SortSet(cls.__Panels)
    @abstractmethod
    def sortKey(self):
        pass
    @staticmethod
    def __sortkey(item):
        return item.sortKey()
    @classmethod 
    def SortSet(cls,panelSet):
        panelList =  list(panelSet)
        panelList.sort(key=cls.__sortkey)
        return panelList

class Panel(BirchPanel,InstanceIter):
    def sortKey(self):
        bbox = self.panel.BoundBox
        if self.side=='end':
            return math.hypot(bbox.ZLength,bbox.XLength)
        elif self.side=='side':
            return math.hypot(bbox.ZLength,bbox.YLength)
        elif self.side=='bottom':
            return math.hypot(bbox.XLength,bbox.YLength)
    def __str__(self):
        try:
            result = '<Panel name="'+self.name+'"'
            result = result+', origin='+str(self.origin)
            result = result+', side="'+self.side+'">'
            return result
        except BaseException:
            return "<Panel>"
    def __init__(self,name,origin,width,height,*,side='end'):
        super(Panel,self).__init__()
        self.name = name
        if not isinstance(origin,Base.Vector):
            raise RuntimeError("origin is not a Vector!")
        self.origin = origin
        self.side = side
        if self.side == 'side':
            norm = Base.Vector(1,0,0)
        elif self.side == 'end':
            norm = Base.Vector(0,1,0)
        elif self.side == 'bottom':
            norm = Base.Vector(0,0,1)
        else:
            raise RuntimeError("unsuported side!")
        panel = Part.makePlane(height,
                               width,
                               self.origin,
                               norm).extrude(norm * -BirchPanel.Thickness())
        self.panel = panel
    def show(self,doc=None):
        if doc==None:
            doc = App.activeDocument()
        obj = doc.addObject("Part::Feature",self.name)
        obj.Shape = self.panel
        obj.Label=self.name
        obj.ViewObject.ShapeColor=self.Color
    def CutXZfingers(self,*,startx=0,endx=0,zoffset=0,yoffset=0):
        x = startx
        ZNorm=Base.Vector(0,0,1)
        panel = self.panel
        while x <= endx:
            panel = panel.cut(Part.makePlane(self.FingerWidth,\
                                             BirchPanel.Thickness(),\
                                             self.origin.add(Base.Vector(x,yoffset,zoffset)),\
                                             ZNorm).extrude(Base.Vector(0,0,BirchPanel.Thickness())))
            x += self.FingerWidth*2
        self.panel =  panel
    def CutYZfingers(self,*,starty=0,endy=0,zoffset=0,xoffset=0):
        y = starty
        ZNorm=Base.Vector(0,0,1) 
        panel = self.panel
        while y <= endy:
            panel = panel.cut(Part.makePlane(BirchPanel.Thickness(),\
                                             self.FingerWidth,\
                                             self.origin.add(Base.Vector(xoffset,y,zoffset)),\
                                             ZNorm).extrude(Base.Vector(0,0,BirchPanel.Thickness())))
            y += self.FingerWidth*2
        self.panel =  panel
    def CutZYfingers(self,*,startz=0,endz=0,yoffset=0,xoffset=0):
        z = startz
        YNorm=Base.Vector(0,1,0)
        panel = self.panel
        while z <= endz:
            panel = panel.cut(Part.makePlane(self.FingerWidth,\
                                             BirchPanel.Thickness(),\
                                             self.origin.add(Base.Vector(xoffset,yoffset,z)),\
                                             YNorm).extrude(Base.Vector(0,BirchPanel.Thickness(),0)))
            z += self.FingerWidth*2
        self.panel =  panel
    def CutOtherPanel(self,otherPanel):
        self.panel = self.panel.cut(otherPanel.panel)
    def CutOtherShape(self,otherShape):
        self.panel = self.panel.cut(otherShape)
    def PanelPage(self,techDoc,page,lastX,lastY,deltaY,*,minX=50,minY=50,
                                             maxX=(24*25.4)-50,
                                             maxY=(16*25.4)-50):
        bbox = self.panel.BoundBox         
        if self.side == 'end':
            direction = Base.Vector(0,1,0)
            lengthX = bbox.XLength
            lengthY = bbox.ZLength
        elif self.side == 'side':
            direction = Base.Vector(1,0,0)
            lengthX = bbox.YLength
            lengthY = bbox.ZLength
        elif self.side == 'bottom':
            direction = Base.Vector(0,0,1)
            lengthX = bbox.XLength
            lengthY = bbox.YLength
        fitP, currentX, currentY, lengthX, lengthY, deltaY, rotation = \
            BirchPanel.FitPanel(page,lastX,lastY,lengthX,lengthY,deltaY,minX,
                                minY, maxX,maxY)
        if not fitP:
            return (True, -1, -1, deltaY)
        #print("*** Panel.PanelPage(): currentX = ",currentX,", currentY = ",currentY)
        #print("*** Panel.PanelPage(): lengthX = ",lengthX,", lengthY = ", lengthY)
        #print("*** Panel.PanelPage(): rotation = ",rotation)
        obj = techDoc.addObject("Part::Feature",self.name)
        obj.Shape = self.panel
        obj.ViewObject.Visibility = False
        panel = techDoc.addObject('TechDraw::DrawViewPart',self.name+"_View")
        page.addView(panel)
        panel.Source = obj
        panel.X = currentX+lengthX/2
        panel.Y = currentY+lengthY/2
        panel.Rotation = rotation
        panel.Direction = direction
        return (True,currentX+lengthX+10,currentY,deltaY)
        
class Coupling(object):
    __QuarterInch = .25*25.4
    __Sixmm = 6
    __Length = 24
    __OuterDia = 18
    __Color = (.8, .8, .8)
    def __init__(self,name,origin):
        self.name = name
        if not isinstance(origin,Base.Vector):
            raise RuntimeError("origin is not a Vector!")
        self.origin = origin
        coupling = Part.makeCylinder(self.__OuterDia/2,self.__Length,
                                     origin.add(Base.Vector(0,
                                                            +self.__Length/2,
                                                            0)),
                                     Base.Vector(0,-1,0))
        motorShaft = Part.makeCylinder(self.__Sixmm/2,self.__Length/2,
                                       origin.add(Base.Vector(0,
                                                              +self.__Length/2,
                                                              0)),
                                       Base.Vector(0,-1,0))
        coupling = coupling.cut(motorShaft)
        rod = Part.makeCylinder(self.__QuarterInch/2,self.__Length/2,
                                origin,
                                Base.Vector(0,-1,0))
        self.coupling = coupling.cut(rod)
    def show(self,doc=None):
        if doc==None:
            doc = App.activeDocument()
        obj = doc.addObject("Part::Feature",self.name)
        obj.Shape = self.coupling
        obj.Label=self.name
        obj.ViewObject.ShapeColor=self.__Color


class QuarterInchBy28ThreaderRod(object):
    __QuarterInch = .25*25.4
    __ThreadsPerInch = 28
    __Inch = 25.4
    __Color = (.8, .8, .8)
    __Pitch =   0.907
    __MajorDiameter = 6.35
    __MinorDiameter = 5.271
    __PitchDiameter = 5.761
    __ThreadHeight =    0.49
    __Addendum = 0.295
    __Root = 0.114
    __LeadAngle = 2.87# degrees
    __Padding = (1/32)*25.4 
    @classmethod
    def makeProfile(cls):
        profheight = cls.__ThreadHeight
        minordiameter = cls.__MinorDiameter
        padding = cls.__Padding
        pitch = cls.__Pitch
        v1 = Base.Vector(minordiameter/2 + profheight + padding, 0, padding/math.sqrt(3))        
        v2 = Base.Vector(minordiameter/2, 0, -pitch*5/16)
        v3 = Base.Vector(minordiameter/2, 0, -pitch*9/16)        
        v4 = Base.Vector(minordiameter/2 + profheight + padding, 0, -pitch*7/8 - padding/math.sqrt(3))
        l1 = Part.LineSegment(v1,v2)
        l3 = Part.LineSegment(v3,v4)
        l4 = Part.LineSegment(v4,v1)
        l2 = Part.LineSegment(v2,v3) 
        sprofile = Part.Shape([l1, l2, l3, l4])
        return Part.Wire(sprofile.Edges)
    def __init__(self,name,origin,length=6*25.4):
        self.name = name
        if not isinstance(origin,Base.Vector):
            raise RuntimeError("origin is not a Vector!")
        self.origin = origin
        shaft = Part.makeCylinder(self.__QuarterInch/2,length,origin,Base.Vector(0,-1,0))
        wprofile = QuarterInchBy28ThreaderRod.makeProfile()
        helixpad = .01
        wprofile.translate(Base.Vector(0,0,-helixpad))
        helix = Part.makeLongHelix(self.__Pitch,length+self.__Pitch+helixpad*2,self.__MajorDiameter/2,0,False)
        helix.translate(Base.Vector(0,0,-helixpad)) 
        thread = Part.BRepOffsetAPI.MakePipeShell(helix)
        thread.setFrenetMode(True)  # Sets a Frenet (true) or a CorrectedFrenet(false) trihedron to perform the sweeping.  False = corkscrew.
        thread.setTransitionMode(1)  # 0=Transformed, *1=right corner transition, 2=Round corner
        thread.add(wprofile, False)	# WithContact = connect to helix.  WithCorrection = orthogonal to helix tangent.
        if not thread.isReady():
            self.rod = shaft
            raise RuntimeError("BRepOffsetAPI not ready error sweeping thread profile.\n")
        thread.build()
        if not thread.makeSolid():
            self.rod = shaft
            raise RuntimeError("BRepOffsetAPI faled building swept thread solid.\n")
        sthread = thread.shape()
        sthread = sthread.rotate(Base.Vector(0,0,0),Base.Vector(1,0,0),90)
        sthread = sthread.translate(origin)
        threadbody = shaft.cut(sthread)
        self.rod = threadbody
        
    def show(self,doc=None):        
        if doc==None:
            doc = App.activeDocument()
        obj = doc.addObject("Part::Feature",self.name)
        obj.Shape = self.rod
        obj.Label=self.name
        obj.ViewObject.ShapeColor=self.__Color

class Bearing_6383K14(object):
    __InsideDiameter = .25*25.4
    __OutsideDiameter = .75*25.4
    __Width = .25*25.4
    __Filename=os.path.join(os.path.dirname(__file__),
                            "6383K14_Ball Bearing.STEP")
    __Color=(.5,.5,.5)
    def __init__(self,name,origin,*,
                 rotationAxis=Base.Vector(1,0,0),rotationAngle=90):
        self.name = name
        if not isinstance(origin,Base.Vector):
            raise RuntimeError("origin is not a Vector!")
        self.origin = origin
        bearing = Part.read(self.__Filename)
        bearing = bearing.rotate(Base.Vector(0,0,0),rotationAxis,rotationAngle)
        self.bearing = bearing.translate(self.origin)
    def show(self,doc=None):
        if doc==None:
            doc = App.activeDocument()
        obj = doc.addObject("Part::Feature",self.name)
        obj.Shape = self.bearing
        obj.Label=self.name
        obj.ViewObject.ShapeColor=self.__Color

class CandyBarLurchPusher(object):
    __PusherHeight = 2*25.4
    __PusherWidth  = 2.5*25.4
    __PusherLength = 6*25.4
    def __init__(self,name,origin):
        self.name = name
        if not isinstance(origin,Base.Vector):
            raise RuntimeError("origin is not a Vector!")
        self.origin = origin
        self.motor = DFRobotGearMotor.DFRobotGearMotor_Left(
                    name+"_Motor",
                    DFRobotGearMotor.DFRobotGearMotor_Left.OriginFromShaftHole(self.origin))
        self.threadedRod = QuarterInchBy28ThreaderRod(
                    name+"_ThreadedRod",
                    origin.add(Base.Vector(0,-41.7,0)),
                    self.__PusherLength)
        self.coupling = Coupling(name+"_Coupling",
                                 origin.add(Base.Vector(0,-41.7,0)))
        endPanelOrigin = origin.add(Base.Vector(-self.__PusherWidth/2,
                      -(DFRobotGearMotor.DFRobotGearMotor.GearBoxDepth+
                        DFRobotGearMotor.DFRobotGearMotor.GearBoxSpacers),
                                                -self.__PusherHeight/2))
        self.endpanel = Panel(name+"_EndPanel",endPanelOrigin,
                              self.__PusherWidth,self.__PusherHeight,
                              side='end')
        self.endpanel.CutOtherShape(self.motor.ShaftHole(endPanelOrigin.y,
                                    -BirchPanel.Thickness()))
        for i in range(4):
            self.endpanel.CutOtherShape(self.motor.MountingHole(i,endPanelOrigin.y,
                                        -BirchPanel.Thickness()))
        self.endpanel.CutXZfingers(endx=self.__PusherWidth,
                                   yoffset=-BirchPanel.Thickness())
        self.endpanel.CutZYfingers(endz=self.__PusherHeight,
                                   yoffset=-BirchPanel.Thickness())
        self.endpanel.CutZYfingers(endz=self.__PusherHeight,
                                   yoffset=-BirchPanel.Thickness(),
                                   xoffset=self.__PusherWidth-
                                            BirchPanel.Thickness())
        self.bottom = Panel(name+"_BottomPanel",
                            endPanelOrigin.add(
                                    Base.Vector(0,-self.__PusherLength*2,
                                                BirchPanel.Thickness())),
                            self.__PusherLength*2,self.__PusherWidth,
                            side='bottom')
        self.bottom.CutOtherPanel(self.endpanel)
        self.bottom.CutYZfingers(endy=self.__PusherLength*2,
                                 zoffset=-BirchPanel.Thickness())
        self.bottom.CutYZfingers(endy=self.__PusherLength*2,
                                 xoffset=self.__PusherWidth-
                                         BirchPanel.Thickness(),
                                 zoffset=-BirchPanel.Thickness())
        self.left=Panel(name+"_LeftPanel",
                        endPanelOrigin.add(Base.Vector(BirchPanel.Thickness(),
                                                       0,0)),
                                self.__PusherLength*2,self.__PusherHeight,
                                side='side')
        self.left.CutOtherPanel(self.endpanel)
        self.left.CutOtherPanel(self.bottom)
        self.right=Panel(name+"_RightPanel",
                        endPanelOrigin.add(Base.Vector(self.__PusherWidth,
                                                       0,0)),
                                self.__PusherLength*2,self.__PusherHeight,
                                side='side')
        self.right.CutOtherPanel(self.endpanel)
        self.right.CutOtherPanel(self.bottom)
        self.pillowBlock = Panel(name+"_PillowBlock",
                                 endPanelOrigin.add(
                                    Base.Vector(BirchPanel.Thickness()*2,
                                                -(self.__PusherLength+13.32),
                                                0)),
                                 self.__PusherWidth-(BirchPanel.Thickness()*4),
                                 self.__PusherHeight,
                                 side='end')
        self.pillowBlock.CutXZfingers(endx=self.__PusherWidth-
                                           (BirchPanel.Thickness()*4),
                                      yoffset=-BirchPanel.Thickness())
        self.bottom.CutOtherPanel(self.pillowBlock)
        self.bearing = Bearing_6383K14(self.name+"_Bearing",
                                       origin.add(
                                        Base.Vector(0,
                                                    -(self.__PusherLength+
                                                      38.53),
                                                    0)))
        self.pillowBlock.CutOtherShape(self.bearing.bearing)
    def show(self,doc=None):
        if doc==None:
            doc = App.activeDocument()
        self.motor.show(doc)
        self.threadedRod.show(doc)
        self.coupling.show(doc)
        self.endpanel.show(doc)
        self.bottom.show(doc)
        self.left.show(doc)
        self.right.show(doc)
        self.pillowBlock.show(doc)
        self.bearing.show(doc)
        

if __name__ == '__main__':
    if "Pusher" in App.listDocuments().keys():
        App.closeDocument("Pusher")
    doc = App.newDocument("Pusher")
    pusher = CandyBarLurchPusher("Pusher",Base.Vector(0,0,0))
    pusher.show(doc)
    Gui.activeDocument().activeView().viewTop()
    Gui.SendMsgToActiveView("ViewFit")
