#*****************************************************************************
#
#  System        : 
#  Module        : 
#  Object Name   : $RCSfile$
#  Revision      : $Revision$
#  Date          : $Date$
#  Author        : $Author$
#  Created By    : Robert Heller
#  Created       : Sun Jul 6 15:01:26 2025
#  Last Modified : <250711.1524>
#
#  Description	
#
#  Notes
#
#  History
#	
#*****************************************************************************
#
#    Copyright (C) 2025  Robert Heller D/B/A Deepwoods Software
#			51 Locke Hill Road
#			Wendell, MA 01379-9728
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# 
#
#*****************************************************************************


import FreeCAD as App
import Part, TechDraw, Mesh, MeshPart, TechDrawGui
from FreeCAD import Base

import math

import os
import sys
sys.path.append(os.path.dirname(__file__))

import DFRobotGearMotor

import time
from PySide.QtCore import QCoreApplication, QEventLoop, QTimer
def execute(loop, ms):
    timer = QTimer()
    timer.setSingleShot(True)
    
    timer.timeout.connect(loop.quit)
    timer.start(ms)
    loop.exec_()

def sleep(ms):
    if not QCoreApplication.instance():
        app = QCoreApplication([])
        execute(app, ms)
    else:
        loop = QEventLoop()
        execute(loop, ms)

from abc import ABCMeta, abstractmethod, abstractproperty

class BirchPanel(metaclass=ABCMeta):
    @staticmethod
    def FitPanel(page,lastX,lastY,lengthX,lengthY,deltaY,minX,minY,maxX,maxY):
        views = page.getAllViews()
        currentX = lastX
        currentY = lastY
        rotation = 0
        if (lengthY > 2*deltaY and lengthX < deltaY) or \
            lengthY > lengthX*2:
            temp = lengthX
            lengthX = lengthY
            lengthY = temp
            rotation = 90
        if currentX+lengthX < maxX and \
           currentY+lengthY < maxY:
            #print("*** BirchPanel.FitPanel(A): deltaY = ",deltaY,", lengthY = ",lengthY)
            deltaY = max(deltaY,lengthY+10)
            return (True, currentX, currentY, lengthX, lengthY, deltaY, rotation)
        elif currentX+lengthX > maxX and \
           currentY+lengthY+deltaY < maxY and \
           minX+lengthX < maxX:
            currentX = minX
            currentY += deltaY
            return (True, currentX, currentY, lengthX, lengthY+10, deltaY, rotation)
        elif currentY+lengthY > maxY and \
             currentY+lengthX < maxY and \
             currentX+lengthY < maxX:
            temp = lengthX
            lengthX = lengthY
            lengthY = temp
            if rotation == 0:
                rotation = 90
            else:
                rotation = 0
            #print("*** BirchPanel.FitPanel(B): deltaY = ",deltaY,", lengthY = ",lengthY)
            deltaY = max(deltaY,lengthY+10)
            return (True, currentX, currentY, lengthX, lengthY, deltaY, rotation)
        elif currentY+deltaY+lengthX < maxY and \
             minX+lengthY < maxX:
            temp = lengthX
            lengthX = lengthY
            lengthY = temp
            if rotation == 0:
                rotation = 90
            else:
                rotation = 0
            currentX = minX
            currentY += deltaY
            return (True, currentX, currentY, lengthX, lengthY+10, deltaY, rotation)
        else:
            return (False, lastX, lastY, lengthX, lengthY, deltaY, rotation)
    @staticmethod
    def Thickness():
        return .125 * 25.4
    @property
    def FingerWidth(self):
        return .5 * 25.4
    @property
    def Color(self):
        return (.8,.8,.8)
    @abstractmethod
    def PanelPage(self,techDoc,page,lastX,lastY,deltaY,*,minX=50,minY=50,
                                             maxX=(24*25.4)-50,
                                             maxY=(16*25.4)-50):
        pass

class InstanceIter(metaclass=ABCMeta):
    @classmethod
    def SetIter(cls):
        #print('*** InstanceIter.__iter__(',cls,')')
        try:
            panels = cls.__Panels
        except AttributeError:
            cls.__Panels = set()
        return cls.__Panels.__iter__()
    def __del__(self):
        #print('*** InstanceIter.__del__(',self,')')
        #print('*** InstanceIter.__del__(): self.__class__ is ',self.__class__)
        try:
            panels = self.__class__.__Panels
        except AttributeError:
            self.__class__.__Panels = set()
        self.__class__.__Panels.remove(self)
    def __init__(self):
        #print('*** InstanceIter.__init__(',self,')')
        #print('*** InstanceIter.__init__(): self.__class__ is ',self.__class__)
        try:
            panels = self.__class__.__Panels
        except AttributeError:
            self.__class__.__Panels = set()
        self.__class__.__Panels.add(self)
        #print('*** InstanceIter.__init__(): self.__class__.__Panels is',self.__class__.__Panels)
    @classmethod
    def SortedList(cls):
        return cls.SortSet(cls.__Panels)
    @abstractmethod
    def sortKey(self):
        pass
    @staticmethod
    def __sortkey(item):
        return item.sortKey()
    @classmethod 
    def SortSet(cls,panelSet):
        panelList =  list(panelSet)
        panelList.sort(key=cls.__sortkey)
        return panelList

class Panel(BirchPanel,InstanceIter):
    def sortKey(self):
        bbox = self.panel.BoundBox
        if self.side=='end':
            return math.hypot(bbox.ZLength,bbox.XLength)
        elif self.side=='side':
            return math.hypot(bbox.ZLength,bbox.YLength)
        elif self.side=='bottom':
            return math.hypot(bbox.XLength,bbox.YLength)
    def __str__(self):
        try:
            result = '<Panel name="'+self.name+'"'
            result = result+', origin='+str(self.origin)
            result = result+', side="'+self.side+'">'
            return result
        except BaseException:
            return "<Panel>"
    def __init__(self,name,origin,width,height,*,side='end'):
        super(Panel,self).__init__()
        self.name = name
        if not isinstance(origin,Base.Vector):
            raise RuntimeError("origin is not a Vector!")
        self.origin = origin
        self.side = side
        if self.side == 'side':
            norm = Base.Vector(1,0,0)
        elif self.side == 'end':
            norm = Base.Vector(0,1,0)
        elif self.side == 'bottom':
            norm = Base.Vector(0,0,1)
        else:
            raise RuntimeError("unsuported side!")
        panel = Part.makePlane(height,
                               width,
                               self.origin,
                               norm).extrude(norm * -BirchPanel.Thickness())
        self.panel = panel
    def show(self,doc=None):
        if doc==None:
            doc = App.activeDocument()
        obj = doc.addObject("Part::Feature",self.name)
        obj.Shape = self.panel
        obj.Label=self.name
        obj.ViewObject.ShapeColor=self.Color
    def CutXZfingers(self,*,startx=0,endx=0,zoffset=0,yoffset=0):
        x = startx
        ZNorm=Base.Vector(0,0,1)
        panel = self.panel
        while x <= endx:
            panel = panel.cut(Part.makePlane(self.FingerWidth,\
                                             BirchPanel.Thickness(),\
                                             self.origin.add(Base.Vector(x,yoffset,zoffset)),\
                                             ZNorm).extrude(Base.Vector(0,0,BirchPanel.Thickness())))
            x += self.FingerWidth*2
        self.panel =  panel
    def CutYZfingers(self,*,starty=0,endy=0,zoffset=0,xoffset=0):
        y = starty
        ZNorm=Base.Vector(0,0,1) 
        panel = self.panel
        while y <= endy:
            panel = panel.cut(Part.makePlane(BirchPanel.Thickness(),\
                                             self.FingerWidth,\
                                             self.origin.add(Base.Vector(xoffset,y,zoffset)),\
                                             ZNorm).extrude(Base.Vector(0,0,BirchPanel.Thickness())))
            y += self.FingerWidth*2
        self.panel =  panel
    def CutZYfingers(self,*,startz=0,endz=0,yoffset=0,xoffset=0):
        z = startz
        YNorm=Base.Vector(0,1,0)
        panel = self.panel
        while z <= endz:
            panel = panel.cut(Part.makePlane(self.FingerWidth,\
                                             BirchPanel.Thickness(),\
                                             self.origin.add(Base.Vector(xoffset,yoffset,z)),\
                                             YNorm).extrude(Base.Vector(0,BirchPanel.Thickness(),0)))
            z += self.FingerWidth*2
        self.panel =  panel
    def CutOtherPanel(self,otherPanel):
        self.panel = self.panel.cut(otherPanel.panel)
    def CutOtherShape(self,otherShape):
        self.panel = self.panel.cut(otherShape)
    def PanelPage(self,techDoc,page,lastX,lastY,deltaY,*,minX=50,minY=50,
                                             maxX=(24*25.4)-50,
                                             maxY=(16*25.4)-50):
        bbox = self.panel.BoundBox         
        if self.side == 'end':
            direction = Base.Vector(0,1,0)
            lengthX = bbox.XLength
            lengthY = bbox.ZLength
        elif self.side == 'side':
            direction = Base.Vector(1,0,0)
            lengthX = bbox.YLength
            lengthY = bbox.ZLength
        elif self.side == 'bottom':
            direction = Base.Vector(0,0,1)
            lengthX = bbox.XLength
            lengthY = bbox.YLength
        fitP, currentX, currentY, lengthX, lengthY, deltaY, rotation = \
            BirchPanel.FitPanel(page,lastX,lastY,lengthX,lengthY,deltaY,minX,
                                minY, maxX,maxY)
        #print("*** BirchPanel.FitPanel(",self.name,") returns deltaY = ",deltaY)
        if not fitP:
            return (True, -1, -1, deltaY)
        #print("*** Panel.PanelPage(): currentX = ",currentX,", currentY = ",currentY)
        #print("*** Panel.PanelPage(): lengthX = ",lengthX,", lengthY = ", lengthY)
        #print("*** Panel.PanelPage(): rotation = ",rotation)
        obj = techDoc.addObject("Part::Feature",self.name)
        obj.Shape = self.panel
        obj.ViewObject.Visibility = False
        panel = techDoc.addObject('TechDraw::DrawViewPart',self.name+"_View")
        page.addView(panel)
        panel.Source = obj
        panel.X = currentX+lengthX/2
        panel.Y = currentY+lengthY/2
        panel.Rotation = rotation
        panel.Direction = direction
        return (True,currentX+lengthX+10,currentY,deltaY)
        
class Coupling(object):
    __QuarterInch = .25*25.4
    __Sixmm = 6
    __Length = 24
    __OuterDia = 18
    __Color = (.8, .8, .8)
    def __init__(self,name,origin):
        self.name = name
        if not isinstance(origin,Base.Vector):
            raise RuntimeError("origin is not a Vector!")
        self.origin = origin
        coupling = Part.makeCylinder(self.__OuterDia/2,self.__Length,
                                     origin.add(Base.Vector(0,
                                                            +self.__Length/2,
                                                            0)),
                                     Base.Vector(0,-1,0))
        motorShaft = Part.makeCylinder(self.__Sixmm/2,self.__Length/2,
                                       origin.add(Base.Vector(0,
                                                              +self.__Length/2,
                                                              0)),
                                       Base.Vector(0,-1,0))
        coupling = coupling.cut(motorShaft)
        rod = Part.makeCylinder(self.__QuarterInch/2,self.__Length/2,
                                origin,
                                Base.Vector(0,-1,0))
        self.coupling = coupling.cut(rod)
    def show(self,doc=None):
        if doc==None:
            doc = App.activeDocument()
        obj = doc.addObject("Part::Feature",self.name)
        obj.Shape = self.coupling
        obj.Label=self.name
        obj.ViewObject.ShapeColor=self.__Color


class QuarterInchBy28ThreadedRod(object):
    __QuarterInch = .25*25.4
    __ThreadsPerInch = 28
    __Inch = 25.4
    __Color = (.8, .8, .8)
    __Pitch =   0.907
    __MajorDiameter = 6.35
    __MinorDiameter = 5.271
    __ThreadHeight =    0.49
    __Padding = (1/32)*25.4 
    @classmethod
    def makeProfile(cls):
        profheight = cls.__ThreadHeight
        minordiameter = cls.__MinorDiameter
        padding = cls.__Padding
        pitch = cls.__Pitch
        v1 = Base.Vector(minordiameter/2 + profheight + padding, 0, padding/math.sqrt(3))        
        v2 = Base.Vector(minordiameter/2, 0, -pitch*5/16)
        v3 = Base.Vector(minordiameter/2, 0, -pitch*9/16)        
        v4 = Base.Vector(minordiameter/2 + profheight + padding, 0, -pitch*7/8 - padding/math.sqrt(3))
        l1 = Part.LineSegment(v1,v2)
        l3 = Part.LineSegment(v3,v4)
        l4 = Part.LineSegment(v4,v1)
        l2 = Part.LineSegment(v2,v3) 
        sprofile = Part.Shape([l1, l2, l3, l4])
        return Part.Wire(sprofile.Edges)
    def __init__(self,name,origin,length=6*25.4):
        self.name = name
        if not isinstance(origin,Base.Vector):
            raise RuntimeError("origin is not a Vector!")
        self.origin = origin
        shaft = Part.makeCylinder(self.__QuarterInch/2,length,origin,Base.Vector(0,-1,0))
        wprofile = QuarterInchBy28ThreadedRod.makeProfile()
        helixpad = .01
        wprofile.translate(Base.Vector(0,0,-helixpad))
        helix = Part.makeLongHelix(self.__Pitch,length+self.__Pitch+helixpad*2,self.__MajorDiameter/2,0,False)
        helix.translate(Base.Vector(0,0,-helixpad)) 
        thread = Part.BRepOffsetAPI.MakePipeShell(helix)
        thread.setFrenetMode(True)  # Sets a Frenet (true) or a CorrectedFrenet(false) trihedron to perform the sweeping.  False = corkscrew.
        thread.setTransitionMode(1)  # 0=Transformed, *1=right corner transition, 2=Round corner
        thread.add(wprofile, False)	# WithContact = connect to helix.  WithCorrection = orthogonal to helix tangent.
        if not thread.isReady():
            self.rod = shaft
            raise RuntimeError("BRepOffsetAPI not ready error sweeping thread profile.\n")
        thread.build()
        if not thread.makeSolid():
            self.rod = shaft
            raise RuntimeError("BRepOffsetAPI faled building swept thread solid.\n")
        sthread = thread.shape()
        sthread = sthread.rotate(Base.Vector(0,0,0),Base.Vector(1,0,0),90)
        sthread = sthread.translate(origin)
        threadbody = shaft.cut(sthread)
        self.rod = threadbody
        
    def show(self,doc=None):        
        if doc==None:
            doc = App.activeDocument()
        obj = doc.addObject("Part::Feature",self.name)
        obj.Shape = self.rod
        obj.Label=self.name
        obj.ViewObject.ShapeColor=self.__Color

class QuarterInchBy20ThreadedRod(object):
    __QuarterInch = .25*25.4
    __ThreadsPerInch = 20
    __Inch = 25.4
    __Color = (.8, .8, .8)
    __Pitch =   1.270
    __MajorDiameter = 6.35
    __MinorDiameter = 4.79298
    __ThreadHeight =    (6.35-4.79298)/2
    __Padding = (1/32)*25.4 
    @classmethod
    def makeProfile(cls):
        profheight = cls.__ThreadHeight
        minordiameter = cls.__MinorDiameter
        padding = cls.__Padding
        pitch = cls.__Pitch
        v1 = Base.Vector(minordiameter/2 + profheight + padding, 0, padding/math.sqrt(3))        
        v2 = Base.Vector(minordiameter/2, 0, -pitch*5/16)
        v3 = Base.Vector(minordiameter/2, 0, -pitch*9/16)        
        v4 = Base.Vector(minordiameter/2 + profheight + padding, 0, -pitch*7/8 - padding/math.sqrt(3))
        l1 = Part.LineSegment(v1,v2)
        l3 = Part.LineSegment(v3,v4)
        l4 = Part.LineSegment(v4,v1)
        l2 = Part.LineSegment(v2,v3) 
        sprofile = Part.Shape([l1, l2, l3, l4])
        return Part.Wire(sprofile.Edges)
    def __init__(self,name,origin,length=6*25.4):
        self.name = name
        if not isinstance(origin,Base.Vector):
            raise RuntimeError("origin is not a Vector!")
        self.origin = origin
        shaft = Part.makeCylinder(self.__QuarterInch/2,length,origin,Base.Vector(0,-1,0))
        wprofile = QuarterInchBy20ThreadedRod.makeProfile()
        helixpad = .01
        wprofile.translate(Base.Vector(0,0,-helixpad))
        helix = Part.makeLongHelix(self.__Pitch,length+self.__Pitch+helixpad*2,self.__MajorDiameter/2,0,False)
        helix.translate(Base.Vector(0,0,-helixpad)) 
        thread = Part.BRepOffsetAPI.MakePipeShell(helix)
        thread.setFrenetMode(True)  # Sets a Frenet (true) or a CorrectedFrenet(false) trihedron to perform the sweeping.  False = corkscrew.
        thread.setTransitionMode(1)  # 0=Transformed, *1=right corner transition, 2=Round corner
        thread.add(wprofile, False)	# WithContact = connect to helix.  WithCorrection = orthogonal to helix tangent.
        if not thread.isReady():
            self.rod = shaft
            raise RuntimeError("BRepOffsetAPI not ready error sweeping thread profile.\n")
        thread.build()
        if not thread.makeSolid():
            self.rod = shaft
            raise RuntimeError("BRepOffsetAPI faled building swept thread solid.\n")
        sthread = thread.shape()
        sthread = sthread.rotate(Base.Vector(0,0,0),Base.Vector(1,0,0),90)
        sthread = sthread.translate(origin)
        threadbody = shaft.cut(sthread)
        self.rod = threadbody
        
    def show(self,doc=None):        
        if doc==None:
            doc = App.activeDocument()
        obj = doc.addObject("Part::Feature",self.name)
        obj.Shape = self.rod
        obj.Label=self.name
        obj.ViewObject.ShapeColor=self.__Color

class Bearing_6383K14(object):
    __InsideDiameter = .25*25.4
    __OutsideDiameter = .75*25.4
    __Width = .25*25.4
    __Filename=os.path.join(os.path.dirname(__file__),
                            "6383K14_Ball Bearing.STEP")
    __Color=(.5,.5,.5)
    def BearingHole(self,Y,Depth):
        holeOrigin=Base.Vector(self.origin.x,self.origin.y+Y,self.origin.z)
        return(Part.makeCylinder(self.__OutsideDiameter/2,Depth,holeOrigin,Base.Vector(0,-1,0)))
    def __init__(self,name,origin,*,
                 rotationAxis=Base.Vector(1,0,0),rotationAngle=90):
        self.name = name
        if not isinstance(origin,Base.Vector):
            raise RuntimeError("origin is not a Vector!")
        self.origin = origin
        bearing = Part.read(self.__Filename)
        bearing = bearing.rotate(Base.Vector(0,0,0),rotationAxis,rotationAngle)
        self.bearing = bearing.translate(self.origin)
    def show(self,doc=None):
        if doc==None:
            doc = App.activeDocument()
        obj = doc.addObject("Part::Feature",self.name)
        obj.Shape = self.bearing
        obj.Label=self.name
        obj.ViewObject.ShapeColor=self.__Color

class Steel_Tee_Nut_Inserts(metaclass=ABCMeta):
    @abstractproperty
    def Filename(self):
        pass
    @abstractproperty
    def NutHoleDiameter(self):
        pass
    @abstractproperty
    def NutHoleLength(self):
        pass
    def HoleCut(self,*,dir=Base.Vector(0,-1,0)):
        length = self.NutHoleLength
        s=Part.makeCylinder(self.NutHoleDiameter/2,length,self.origin,dir)
        return s
    __Color=(.5,.5,.5)
    def __init__(self,name,origin,*,
                 rotationAxis=Base.Vector(1,0,0),rotationAngle=180):
        self.name = name
        if not isinstance(origin,Base.Vector):
            raise RuntimeError("origin is not a Vector!")
        self.origin = origin
        nut = Part.read(self.Filename)
        nut = nut.rotate(Base.Vector(0,0,0),rotationAxis,rotationAngle)
        self.nut = nut.translate(self.origin)
    def show(self,doc=None):
        if doc==None:
            doc = App.activeDocument()
        obj = doc.addObject("Part::Feature",self.name)
        obj.Shape = self.nut
        obj.Label=self.name
        obj.ViewObject.ShapeColor=self.__Color

class Steel_Tee_Nut_Inserts_90975A102(Steel_Tee_Nut_Inserts):
    @property
    def Filename(self):
        return os.path.join(os.path.dirname(__file__),
                            "90975A102_Steel Tee Nut Inserts.STEP")
    @property
    def NutHoleDiameter(self):
        return .17*25.4
    @property
    def NutHoleLength(self):
        return .25*25.4
class Steel_Tee_Nut_Inserts_90975A104(Steel_Tee_Nut_Inserts):
    @property
    def Filename(self):
        return os.path.join(os.path.dirname(__file__),
                            "90975A104_Steel Tee Nut Inserts.STEP")
    @property
    def NutHoleDiameter(self):
        return .305*25.4
    @property
    def NutHoleLength(self):
        return (3/16)*25.4

class XCG3_S1Z1(object):
    __Filename = os.path.join(os.path.dirname(__file__),"XCG3-S1Z1.stp")
    __Color = (0.0,0.0,0.0)
    RollerDepth = 9.95-4.91
    SwitchBodyWidth = 19.9
    SwitchBodyThickness = 6.4
    SwitchBodyHeight = 9.5
    def __init__(self,name,origin,*,
                 rotationAxis=Base.Vector(0,0,1),rotationAngle=90):
        self.name = name
        if not isinstance(origin,Base.Vector):
            raise RuntimeError("origin is not a Vector!")
        self.origin = origin
        switch = Part.read(self.__Filename)
        switch = switch.rotate(Base.Vector(0,0,0),Base.Vector(0,1,0),90)
        switch = switch.rotate(Base.Vector(0,0,0),rotationAxis,rotationAngle)
        switch = switch.translate(self.origin)
        self.switch = switch
    def show(self,doc=None):
        if doc==None:
            doc = App.activeDocument()
        obj = doc.addObject("Part::Feature",self.name)
        obj.Shape = self.switch
        obj.Label=self.name
        obj.ViewObject.ShapeColor=self.__Color

class CandyBarLurchPusher(object):
    __PusherHeight = 2*25.4
    __PusherWidth  = 2.5*25.4
    __PusherLength = 6*25.4
    __LimitSwitchMountThickness = XCG3_S1Z1.SwitchBodyHeight
    __LimitSwitchMountHeight = 2*25.4+\
                                XCG3_S1Z1.SwitchBodyWidth-\
                                BirchPanel.Thickness()-\
                                XCG3_S1Z1.RollerDepth
    __LimitSwitchMountWidth = 2.5*25.4-\
                    (BirchPanel.Thickness()*4)-\
                    10-\
                    (XCG3_S1Z1.SwitchBodyThickness*2)
    __LimitSwitchMountOffset = Base.Vector(XCG3_S1Z1.SwitchBodyThickness+3,
                                           -BirchPanel.Thickness()*2,
                                           BirchPanel.Thickness())
    def __LimitSwitchMount(self):
        limitswitchorigin = self.pillowBlockOrigin.add(
                                        self.__LimitSwitchMountOffset)
        limitswitchmount  = Part.makePlane(self.__LimitSwitchMountHeight,
                                           self.__LimitSwitchMountWidth,
                                           limitswitchorigin,
                                           Base.Vector(0,1,0))\
                  .extrude(Base.Vector(0,self.__LimitSwitchMountThickness,0))
        limitswitchmount = limitswitchmount.cut(self.pillowBlock.panel)
        self.limitswitchmount = limitswitchmount.cut(
                self.bearing.BearingHole(BirchPanel.Thickness(),
                                         self.__LimitSwitchMountThickness))
        self.limitswitch1 = XCG3_S1Z1(self.name+"_LimitSwitch1",
                                      limitswitchorigin.add(
                                        Base.Vector(
                                            0,
                                            XCG3_S1Z1.SwitchBodyHeight/2,
                                            self.__LimitSwitchMountHeight-
                                                (XCG3_S1Z1.SwitchBodyWidth/2))))
        self.limitswitch2 = XCG3_S1Z1(self.name+"_LimitSwitch2",
                                      limitswitchorigin.add(
                                        Base.Vector(
                                            self.__LimitSwitchMountWidth,
                                            XCG3_S1Z1.SwitchBodyHeight/2,
                                            self.__LimitSwitchMountHeight-
                                                (XCG3_S1Z1.SwitchBodyWidth/2))),
                                      rotationAngle=270)

    def __init__(self,name,origin):
        self.name = name
        if not isinstance(origin,Base.Vector):
            raise RuntimeError("origin is not a Vector!")
        self.origin = origin
        self.motor = DFRobotGearMotor.DFRobotGearMotor_Left(
                    name+"_Motor",
                    DFRobotGearMotor.DFRobotGearMotor_Left.OriginFromShaftHole(self.origin))
        self.threadedRod = QuarterInchBy20ThreadedRod(
                    name+"_ThreadedRod",
                    origin.add(Base.Vector(0,-41.7,0)),
                    self.__PusherLength)
        self.coupling = Coupling(name+"_Coupling",
                                 origin.add(Base.Vector(0,-41.7,0)))
        endPanelOrigin = origin.add(Base.Vector(-self.__PusherWidth/2,
                      -(DFRobotGearMotor.DFRobotGearMotor.GearBoxDepth+
                        DFRobotGearMotor.DFRobotGearMotor.GearBoxSpacers),
                                                -self.__PusherHeight/2))
        self.endpanel = Panel(name+"_EndPanel",endPanelOrigin,
                              self.__PusherWidth,self.__PusherHeight,
                              side='end')
        self.endpanel.CutOtherShape(self.motor.ShaftHole(endPanelOrigin.y,
                                    -BirchPanel.Thickness()))
        for i in range(4):
            self.endpanel.CutOtherShape(self.motor.MountingHole(i,endPanelOrigin.y,
                                        -BirchPanel.Thickness()))
        self.endpanel.CutXZfingers(endx=self.__PusherWidth,
                                   yoffset=-BirchPanel.Thickness())
        self.endpanel.CutZYfingers(endz=self.__PusherHeight,
                                   yoffset=-BirchPanel.Thickness())
        self.endpanel.CutZYfingers(endz=self.__PusherHeight,
                                   yoffset=-BirchPanel.Thickness(),
                                   xoffset=self.__PusherWidth-
                                            BirchPanel.Thickness())
        bottomlen = self.__PusherLength*2 - 25.4
        sidelen = bottomlen - 25.4
        self.bottom = Panel(name+"_BottomPanel",
                            endPanelOrigin.add(
                                    Base.Vector(0,-bottomlen,
                                                BirchPanel.Thickness())),
                            bottomlen,self.__PusherWidth,
                            side='bottom')
        self.bottom.CutOtherPanel(self.endpanel)
        self.bottom.CutYZfingers(starty=25.4,endy=bottomlen,
                                 zoffset=-BirchPanel.Thickness())
        self.bottom.CutYZfingers(starty=25.4,endy=bottomlen,
                                 xoffset=self.__PusherWidth-
                                         BirchPanel.Thickness(),
                                 zoffset=-BirchPanel.Thickness())
        self.left=Panel(name+"_LeftPanel",
                        endPanelOrigin.add(Base.Vector(BirchPanel.Thickness(),
                                                       0,0)),
                                sidelen,self.__PusherHeight,
                                side='side')
        self.left.CutOtherPanel(self.endpanel)
        self.left.CutOtherPanel(self.bottom)
        self.right=Panel(name+"_RightPanel",
                        endPanelOrigin.add(Base.Vector(self.__PusherWidth,
                                                       0,0)),
                                sidelen,self.__PusherHeight,
                                side='side')
        self.right.CutOtherPanel(self.endpanel)
        self.right.CutOtherPanel(self.bottom)
        self.pillowBlockOrigin = endPanelOrigin.add(
                                    Base.Vector((BirchPanel.Thickness()*2)+2,
                                                -(self.__PusherLength+13.32),
                                                0))
        self.pillowBlock = Panel(name+"_PillowBlock",
                                 self.pillowBlockOrigin,
                                 self.__PusherWidth-(BirchPanel.Thickness()*4)-4,
                                 self.__PusherHeight-XCG3_S1Z1.RollerDepth,
                                 side='end')
        self.pillowBlock.CutXZfingers(endx=self.__PusherWidth-
                                           (BirchPanel.Thickness()*4),
                                      yoffset=-BirchPanel.Thickness())
        self.bottom.CutOtherPanel(self.pillowBlock)
        self.bearing = Bearing_6383K14(self.name+"_Bearing",
                                       origin.add(
                                        Base.Vector(0,
                                                    -(self.__PusherLength+
                                                      38.53),
                                                    0)))
        self.pillowBlock.CutOtherShape(
                self.bearing.BearingHole(BirchPanel.Thickness(),BirchPanel.Thickness()*3))
        pusherBaseOrigin = origin.add(
                            Base.Vector(0,-(65+(BirchPanel.Thickness()*2)),
                                        0))
        plength = self.__PusherLength-(3*BirchPanel.Thickness())
        pwidth = self.__PusherWidth-(2*BirchPanel.Thickness())-2
        pheight = self.__PusherHeight-BirchPanel.Thickness()
        pusherEndOrigin = pusherBaseOrigin.add(
                                Base.Vector(-pwidth/2,
                                            -BirchPanel.Thickness(),
                                            -pheight/2+1.6))
        self.pusherEnd = Panel(name+"_PusherEndPanel",
                               pusherEndOrigin,
                               pwidth,pheight,side='end')
        self.pusherTNut = Steel_Tee_Nut_Inserts_90975A104(name+"_PusherTNut",
                                pusherBaseOrigin.add(
                                    Base.Vector(0,-(BirchPanel.Thickness()-
                                                    (.047*25.4)),0)))
        self.pusherEnd.CutOtherShape(self.pusherTNut.HoleCut())
        self.pusherEnd.CutZYfingers(endz=pheight,
                                    yoffset=-BirchPanel.Thickness())
        self.pusherEnd.CutZYfingers(endz=pheight,
                                    yoffset=-BirchPanel.Thickness(),
                                    xoffset=pwidth-BirchPanel.Thickness())
        self.pusherEndPlate = Panel(name+"_PusherEndPlate",
                                    pusherBaseOrigin.add(
                                        Base.Vector(-18.75,
                                                     (.047*25.4),
                                                    -18.75)),
                                    38.1,38.1,side='end')
        self.pusherEndPlate.CutOtherShape(
            Part.makeCylinder(self.pusherTNut.NutHoleDiameter/2,
                              BirchPanel.Thickness()*2,
                              self.pusherTNut.origin,
                              Base.Vector(0,1,0)))
        xys = [(-9.525,-9.525),(-9.525,9.525),(9.525,-9.525),(9.525,9.525)]
        self.pusherEndTNs = list()
        for i,xy in enumerate(xys):
            x,y = xy
            nut = Steel_Tee_Nut_Inserts_90975A102(name+"_PusherPlaneTNut%d"%
                                                        (i),
                                                  pusherBaseOrigin.add(
                                                    Base.Vector(x,
                                                                -(BirchPanel.Thickness()*2+(.031*25.4)),
                                                                y)),
                                                 rotationAngle=0)
            self.pusherEndTNs.append(nut)
            hole = Part.makeCylinder(nut.NutHoleDiameter/2,
                                  BirchPanel.Thickness()*3,
                                  nut.origin,Base.Vector(0,1,0))
            self.pusherEnd.CutOtherShape(hole)
            self.pusherEndPlate.CutOtherShape(hole)
        plength = self.__PusherLength-(21.53-BirchPanel.Thickness()*2)
        self.leftPusher=Panel(name+"_LeftPusherPanel",
                              pusherEndOrigin.add(
                                Base.Vector(BirchPanel.Thickness(),0,0)),
                              plength,pheight,side='side')
        self.leftPusher.CutOtherPanel(self.pusherEnd)
        self.rightPusher=Panel(name+"_RightPusherPanel",
                               pusherEndOrigin.add(Base.Vector(pwidth,0,0)),
                               plength,pheight,side='side')
        self.rightPusher.CutOtherPanel(self.pusherEnd)
        self.pusherFront = Panel(name+"_PuserFront",
                                 pusherEndOrigin.add(
                                    Base.Vector(0,
                                                -plength+
                                                 BirchPanel.Thickness(),0)),
                                 pwidth,pheight,side='end')
        self.pusherFront.CutZYfingers(endz=pheight,
                                      yoffset=-BirchPanel.Thickness())
        self.pusherFront.CutZYfingers(endz=pheight,
                                      yoffset=-BirchPanel.Thickness(),
                                      xoffset=pwidth-BirchPanel.Thickness())
        self.leftPusher.CutOtherPanel(self.pusherFront)
        self.rightPusher.CutOtherPanel(self.pusherFront)
        self.__LimitSwitchMount()
                                      
    def show(self,doc=None):
        if doc==None:
            doc = App.activeDocument()
        self.motor.show(doc)
        self.threadedRod.show(doc)
        self.coupling.show(doc)
        self.endpanel.show(doc)
        self.bottom.show(doc)
        self.left.show(doc)
        self.right.show(doc)
        self.pillowBlock.show(doc)
        self.bearing.show(doc)
        self.pusherEnd.show(doc)
        self.pusherTNut.show(doc)
        self.pusherEndPlate.show(doc)
        for o in self.pusherEndTNs:
            o.show(doc)
        self.leftPusher.show(doc)
        self.rightPusher.show(doc)
        self.pusherFront.show(doc)
        obj = doc.addObject("Part::Feature",self.name+"_LimitSwitchMount")
        obj.Shape = self.limitswitchmount
        obj.Label=self.name+"_LimitSwitchMount"
        obj.ViewObject.ShapeColor=(0.0,1.0,0.0)
        self.limitswitch1.show(doc)
        self.limitswitch2.show(doc)

Pages = list()
def NewPage(techdoc,pagenum=0):
    pagenum += 1
    page = techdoc.addObject('TechDraw::DrawPage','SmallCutPanelPage_%03d'%(pagenum))
    page.Template = techdoc.SmallCutPanelTemplate
    page.ViewObject.show()
    Pages.append((page, pagenum))
    return (page, pagenum)

if __name__ == '__main__':
    if "Pusher" in App.listDocuments().keys():
        App.closeDocument("Pusher")
    doc = App.newDocument("Pusher")
    pusher = CandyBarLurchPusher("Pusher",Base.Vector(0,0,0))
    pusher.show(doc)
    Gui.activeDocument().activeView().viewTop()
    Gui.SendMsgToActiveView("ViewFit")
    if "Pusher_BirchPanels" in App.listDocuments().keys():
        App.closeDocument("Pusher_BirchPanels")
    techdoc = App.newDocument("Pusher_BirchPanels")
    techdoc.addObject('TechDraw::DrawSVGTemplate','SmallCutPanelTemplate')
    techdoc.SmallCutPanelTemplate.Template = os.path.join(
                        os.path.dirname(__file__),"smallcutpanel.svg")
    page, pagenum = NewPage(techdoc)
    pages = list()
    lastX = 50
    lastY = 50
    deltaY = 0
    for panel in Panel.SortedList():
        #print("*** panel is",panel)
        for i in range(2):
            #print("*** i = ",i)
            #print("*** pagenum = ",pagenum,", lastX = ",lastX,", lastY = ",lastY,", deltaY = ",deltaY)
            hasPanel, newX, newY, deltaY = panel.PanelPage(techdoc,
                                                           page,
                                                           lastX,lastY,deltaY)
            if not hasPanel:
                break
            if newX < 0 and newY < 0:
                # need new page
                page, pagenum = NewPage(techdoc,pagenum)
                lastX = 50
                lastY = 50
                deltaY = 0
            else:
                lastX = newX
                lastY = newY
                break
    techdoc.recompute()
    sleep(500)
    for page,number in Pages:
        TechDrawGui.exportPageAsSvg(page,
                     os.path.join(os.path.dirname(__file__),
                                  "Pusher_Panel%03d.svg"%(number)))
        


